\graphicspath{{chapters/ch-developer-guide/figures/}}

\section{How to develop a wrapper}

\subsection{How to develop a Standard Wrapper  \label{sec:developer-guide_wrappers}}

All standard wrappers subclass gsn.wrapper.AbstractWrapper. Subclasses must im-
plement the following four methods:
\begin{enumerate}
	\item \inlinecode{boolean initialize()}
	\item \inlinecode{void finalize()}
	\item \inlinecode{String getWrapperName()}
	\item \inlinecode{DataField[] getOutputFormat()}
\end {enumerate}

Each wrapper is a thread in the GSN. If you want to do some kind of processing
in a fixed time interval, you can override the \inlinecode{run()} method. The run method
is useful for time driven wrappers in which the production of a sensor data is
triggered by a timer.
Optionally, you may wish to override the method
\inlinecode{boolean sendToWrapper(String action, String[] paramNames, Object[]
paramValues)}

\subsubsection {initialize()}
This method is called after the wrapper object creation. For more information
on the life cycle of a wrapper, see \todo{TODO Fix reference}. The complete method
prototype is \inlinecode{public boolean initialize()}.
In this method, the wrapper should try to initialize its connection to the ac-
tual data producing/receiving device(s) (e.g., wireless sensor networks or cam-
eras). The wrapper should return true if it can successfully initialize the con-
nection, false otherwise.
GSN provides access to the wrapper parameters through the
\inlinecode{getActiveAddressBean().getPredicateValue(``parameter-name'')}
method call.
For example, if you have the following fragment in the virtual sensor config-
uration file:
\begin{xmlcode}
	<stream-source ... >
	<address wrapper="x">
		<predicate key="range">100</predicate>
		<predicate key="log">0</predicate>
	</address>
\end{xmlcode}
You can access the initialization parameter named x with the following code :
\inlinecode {if(getActiveAddressBean().getPredicateValue("x") != null)
{...}}
By default GSN assumes that the timestamps of the data produced in a wrap-
per are local, that is, the wrapper produced them using the system (or GSN)
time. If you have cases where this assumption is not valid and GSN should
assume remote timestamps for stream elements, add the following line in the
\inlinecode {initialize()} method:
\inlinecode{setUsingRemoteTimestamp(true);}
\subsubsection {finalize()}
In the \inlinecode{public void finalize()} method, you should release all the resources
you acquired during the initialization procedure or during the life cycle of the
wrapper. Note that this is the last chance for the wrapper to release all its
reserved resources and after this call the wrapper instance virtually won't exist
anymore.
For example, if you open a file in the initialization phase, you should close
it in the finalization phase.

\subsubsection {getWrapperName()}
\inlinecode{public String getWrapperName()} returns a name for the wrapper.

\subsubsection {getOutputFormat()}
\inlinecode{public abstract DataField[] getOutputFormat()} returns a description of
the data structure produced by this wrapper.
This description is an array of \inlinecode{DataField} objects. A \inlinecode{DataField} object
can be created with a call to the constructor \inlinecode{public DataField(String name,
String type, String Description)}. The name is the field name, the type
is one of GSN data types \inlinecode{(TINYINT, SMALLINT, INTEGER, BIGINT, CHAR(\#),
BINARY[(\#)], VARCHAR(\#), DOUBLE, TIME)}. See \inlinecode{gsn.beans.DataTypes} and
\inlinecode{Description} is a text describing the field.
The following examples should help you get started.

\subsubsubsection* {Wireless Sensor Network Example}
Assuming that you have a wrapper for a wireless sensor network which produces
the average temperature and light value of the nodes in the network, you can
implement \inlinecode{getOutputFormat()} as follows:

\begin{javacode}
	public DataField[] getOutputFormat() {
		DataField[] outputFormat = new DataField[2];
		outputFormat[0] = new DataField("Temperature", "double",
			"Average of temperature readings from the sensor network");
		outputFormat[1] = new DataField("light", "double",
			"Average of light readings from the sensor network");
		return outputFormat;
	}
\end{javacode}

\subsubsubsection* {Webcam Example}
If you have a wrapper producing jpeg images as output (e.g., from wireless
camera), the method is similar to below :

\begin{javacode}
	public DataField[] getOutputFormat() {
		DataField[] outputFormat = new DataField[1];
		outputFormat[0] = new DataField("Picture", "binary:jpeg",
			"Picture from the Camera at room BC143");
		return outputFormat;
	}
\end{javacode}

\subsubsection{run()}
Implementation of the \inlinecode{run()} method: as described before, the wrapper acts as
a bridge between the actual hardware device(s) and GSN, thus in order for the
wrapper to produce data, it should keep track of the newly produced data items.
This method is responsible for forwarding (and possibly filtering or aggregating)
the newly received data from the hardware to the GSN engine.
You should not try to start the thread by yourself: GSN takes care of this.

The method should be implemented as below :
\begin{javacode}
	try {
		//The delay needed for the GSN container to initialize itself.
		//Removing this line might cause hard to find random exceptions
		Thread.sleep (2000);
		} catch (InterruptedException e1) {
			e1.printStackTrace();
		}
		while(isActive()) {
			if(listeners.isEmpty())
				continue;
			if (isLatestReceivedDataProcessed == false) {
				//Application dependent processing ...
				StreamElement streamElement = new StreamElement ( ...);
				isLatestReceivedDataProcessed = true;
				publishData ( streamElement );
		}
	}
\end{javacode}

\subsubsubsection*{Webcam example}
Assume that we have a wireless camera which runs a HTTP server and provides
pictures whenever it receives a \inlinecode{GET} request. In this case we are in a data on
demand scenario (most of the network cameras are like this). To get the data
at the rate of 1 picture every 5 seconds we can do the following :

\begin{javacode}
	while(isActive()) {
		byte[] received_image = null;
		if(listeners.isEmpty())
			continue;
		received_image= getPictureFromCamera();
		StreamElement streamElement = new StreamElement(
			new String[] { "PIC" },
			new Integer [] { Types.BINARY },
			new Serializable[] {received_image},
			System.currentTimeMillis ())
		);
		publishData(streamElement);
		Thread.sleep(5*1000); // Sleeping 5 seconds
	}
\end{javacode}

\subsubsubsection*{Data driven systems}
Compared to the previous example, we do sometimes deal with devices that are
data driven. This means that we don't have control of either when the data is
produced by them (e.g., when they do the capturing) or the rate at which
data is received from them.
For example, having an alarm system, we don't know when we
are going to receive a packet, or how frequently the alarm system will send
data packets to GSN. These kind of systems are typically implemented using a
callback interface. In the callback interface, one needs to set a flag indicating
the data reception state of the wrapper and control that flag in the run method
to process the received data.

\subsubsection{sendToWrapper()}
Most devices, in addition to producing data, can also be controlled. You can
override the method
\inlinecode{public boolean sendToWrapper(String action, String[] paramNames,
Object[] paramValues) throws OperationNotSupportedException}
if you want to offer this possibility to the users of your wrapper.
You can consult the \inlinecode{gsn.wrappers.general.SerialWrapper} class for an
example.

\subsection{A detailed description of the AbstractWrapper class}
In GSN, a wrapper is piece of Java code which acts as a bridge between the actual
data producing/receiving device (e.g., sensor network, RFID reader, webcam...)
and the GSN platform. A GSN wrapper should extend the \inlinecode{gsn.wrapper.AbstractWrapper}
class. This class provides the following methods and data fields:

\begin{javacode}
	public static final String TIME_FIELD = "TIMED";
	public AddressBean getActiveAddressBean();
	public int getListenersSize();
	public ArrayList<DataListener> getListeners();
	public CharSequence addListener(DataListener dataListener);
	public void removeListener(DataListener dataListener);
	public int getDBAlias();
	public boolean sendToWrapper(String action,
		String[] paramNames, Object[] paramValues)
			throws OperationNotSupportedException;
	// Abstract methods
	public abstract boolean initialize();
	pulic abstract void finalize();
	public abstract String getWrapperName();
	public abstract DataField[] getOutputFormat();
\end{javacode}

In GSN, the wrappers can not only receive data from a source, but also send
data to it. Thus wrappers are actually two-way bridges between GSN and the
data source. In the wrapper interface, the method sendToWrapper is called
whenever there is a data item which should be send to the source. A data
item could be as simple as a command for turning on a sensor inside the sensor
network, or it could be as complex as a complete routing table which should
be used for routing the packets in the sensor network. The full syntax of 
\inlinecode{sendToWrapper} is depicted below.
\begin{javacode}
	public boolean sendToWrapper(String action,
		String[] paramNames, Object[] paramValues)
		throws OperationNotSupportedException;
\end{javacode}
The default implementation of the afore-mentioned method throws an \inlinecode{OperationNotSupportedException}
exception because the wrapper doesn't support this operation. This design
choice is justified by the observation that not all kind of devices (sensors) can
accept data from a computer. For instance, a typical wireless camera doesn't
accept commands from the wrapper. If the sensing device supports this oper-
ation, one needs to override this method so that instead of the default action
(throwing the exception), the wrapper sends the data to the sensor network.

\subsection{The life cycle of a wrapper}
An instance of a wrapper is created whenever a Wrapper Connection Request
(WCR) is received by the Wrappers Repository (WR). The WCRs are generated
whenever GSN wants to activate a new virtual sensor. A WCR is generated for
each stream source in the virtual sensor.
A Wrapper Connection Request is an object which contains a wrapper name
and its initialization parameters as defined in the Virtual Sensor Definition
file (\vsd). Therefore, two WCRs are identicals if their wrapper name and initial-
ization parameters are the same. The Wrappers Repository in a GSN instance
is a repository of the active wrapper instances indexed by their WCRs

Whenever a WCR is generated at the virtual sensor loader, it will be sent
to the WR which does the following steps (as illustrated on Figure 5.1 on the
previous page):
\begin{enumerate}
\item Look for a wrapper instance in the repository which has the identical
WCR. If found, WR registers the stream-source query with the wrapper
and returns true.
\item If there is no such WCR in the repository, the WR instantiates the appro-
priate wrapper object and calls its \inlinecode{initialize} method. If the \inlinecode{initialize}
method returns true, WR will add the wrapper instance to the WR. Back
to Step 1.
\item If there is no WCR in the repository and the WR can not initialize the
new wrapper using the specified initialization parameters and GSN context
(e.g., the \inlinecode{initialize} method returns false), WR returns false to the
virtual sensor loader. When the virtual sensor loader receives false, it
tries the next wrapper (if there is any) . The virtual sensor loader fails to
load a virtual sensor if at least one of the stream sources required by an
input stream fails.
\end{enumerate}

The two main reasons behind using the wrappers repository are:
\begin{itemize}
\item Sharing the processing power by performing query merging.
\item Reducing the storage when several stream sources use the same wrappers.
\end{itemize}TheWrapper Disconnect Request (WDR) is generated at the virtual-sensor-loader
whenever GSN wants to release resources used by a virtual sensor. Typically,
when the user removes a virtual sensor configuration while GSN is running, the
virtual-sensor-loader generates a WDR for each stream source that was previ-
ously used by this virtual sensor.
When WR receives a WDR request, it de-registers the stream-source query
from the wrapper. If after removing the stream source query from the wrapper,
there are no queries registered with this wrapper (e.g., no other stream source is
using the considered wrapper), WR calls the finalize method of the wrapper
instance so that all its allocated resources will be released.

\newpage
\subsection{How to develop a Safe Storage Wrapper}

This section describes step by step the development of wrappers that support the Safe Storage feature described in the \chapref{safe_storage}.
As an example to picture this development we use the Safe Storage Memory Monitor wrapper (\inlinecode{ss\_mem\_wrapper}), based on the 
standard one (\inlinecode{memory-usage}).

\begin{enumerate}
	\item In the package \inlinecode{gsn.acquisition2.wrappers},
        create the class that will execute in the Safe Storage process. By convention we name these classes like the following:
        \inlinecode{<Old wrapper name>2.java} (for our example \inlinecode{MemoryMontoringWrapper2.java}). This class must extend the abstract class
        \inlinecode{gsn.acquisition2.wrappers.AbstractWrapper2}.

	\item Add a short name link for this new class in the file:\\ \inlinecode{conf/safe\_storage\_wrappers.properties}.\\For our example we added: \\
        \inlinecode{mem2=gsn.acquisition2.wrappers.MemoryMontoringWrapper2}.

	\item Create the class that will execute on the GSN process. By convention we name these classes like the following:
	\inlinecode{<Old wrapper name>Processor.java} (for our example \inlinecode{MemoryWrapperProcessor}). This class must extend the abstract class
	\inlinecode{gsn.acquisition2.wrappers.SafeStorageAbstractWrapper}.

	\item Add a short name definition to this new class in the file:\\ \inlinecode{conf/wrappers.properties}.\\ For our example we added:\\
	\inlinecode{ss\_mem\_processor=gsn.acquisition2.wrappers.MemoryWrapperProcessor}.

	\item Create a Virtual Sensor Description file for the sensor you will use to test your wrapper. For our example we created the file:\\
	\inlinecode{virtual-sensors/safe-storage/ss\_mem\_vs.xml}. \\
	Your \vsd file must contain at least the following predicates which are mandatory for Safe Storage feature as shown in the \tableref{table:safe_storage_parameters}.
	\begin{xmlcode}
	<address wrapper="GSN_SHORT_NAME (eg. ss_mem_processor)">
		<predicate key="ss-host">SAFE_STORAGE_HOST (default: localhost)</predicate>
		<predicate key="ss-port">SAFE_STORAGE_PORT (default: 25000)</predicate>
		<predicate key="wrapper-name">SAFE_STORAGE_SHORT_NAME (eg. mem2)</predicate>
	</address>
	\end{xmlcode}

	\item Edit the wrapper class that runs on the Safe Storage process (for our example: \inlinecode{MemoryMontoringWrapper2}).
	Four methods have to be implemented

	\begin{itemize}
		\item \inlinecode{boolean initialize ()} \\
		This method is called after the instanciation of the wrapper class.
		It is used to create the resources according to the parameters set in the configuration file. 
		Your implementation must return false if some mandatory parameters were missing or if any error
		arise during this phase. 
		In the other case, this method must return true.
		%You can get the parameters values from the \vsd file (tags \inlinecode{<predicate key="..../>}) with the 
		%\inlinecode{getPredicate[s|Value|ValueAsInt|...]} methods on the ActiveAddressBean instance accessible with the super class 
		%\inlinecode{getActiveAddressBean()} method. Some of these accessors
		%throw (Unmanaged) \inlinecode{RuntimeException} if the parameter if missing and should be used for mandatory parameters. If you have parameters that are
		%optionnal, you should use the \inlinecode{getPredicateValueWithDefault(key, defaultValue)} accessor.
		
		\item \inlinecode{void finalize ()} \\
		This method should be used to free the wrapper ressources. It is called when the wrapper is unloaded.

		\item \inlinecode{String getWrapperName ()} \\
		This method returns the SafeStorage wrapper's name.

		\item \inlinecode{void run ()} \\
		Each wrapper runs in a separate thread. Use the run method to get data from your device and store them to
		the Safe Storage database with the method \inlinecode{postStreamElement (Serializable[])}.
		Notice that you can pass has many parameters has you want to this method but you must set the current time as the last parameter. 
		This parameter will tag the creation of the packet in SafeStorage and is only necessary for running SafeStorage. %TODO remove this parameter in the code.

		For our example: \\
		\inlinecode{postStreamElement(heapMemoryUsage,nonHeapMemoryUsage,pendingFinalizationCount,System.currentTimeMillis());}
	\end{itemize}

	\item Edit the wrapper class that runs on the GSN part (in our case \inlinecode{MemoryWrapperProcessor}).
	Two methods have to be implemented

	\begin{itemize}
		\item \inlinecode{DataField[] getOutputFormat ()} \\
		This method return an array of fields (names, and types) that are produced by the \wrapper.

		\item \inlinecode{boolean messageToBeProcessed (DataMsg dataMessage)} \\
		This method is called upon reception of a new message from the SafeStorage.
		You can access the data (an array of Serializable objects) with the instance method \inlinecode{dataMessage.getData()}.
		The last element in this array is still the TimeStamp that you added before.\\ % TODO remove this parameter in the code
		Once you have parsed your data, you must use one of the \inlinecode{postStreamElement()} method to store data into GSN.
%
%		\item \inlinecode{postStreamElement(long timestamp, Serializable[] values)} \\
%		use the specified timestamp.
%	
%		\item \inlinecode{postStreamElement(Serializable[] values)} \\
%		use the current time as timestamp.
	\end{itemize}

	\item If you need to get some parameters from the VS XML configuration file, to initialize or finalize your wrapper, you can override 
	the superclass methods:

	\begin{itemize}
		\item \inlinecode{boolean initialize()}
		\item \inlinecode{void finalize()}
	\end{itemize}
\end{enumerate}

