#!/bin/sh

SUBPROCESS_FAKE_ROOT_FOLDER=/tmp/subprocessfake/
SUBFOLDER_NEW=new/
SUBFOLDER_FINISH=finish/



create_exec_command() {
SCRIPT=$(cat <<EOF
#!/bin/sh

PID=\$\$
FILENAME=\$1
FINISHDIR=\$2
RMDIR=\$3

# make sure the file is removed when we exit
trap "rm -f \${RMDIR}\${FILENAME}; echo 1 > \${FINISHDIR}\${FILENAME}.ret; exit" INT TERM

echo \${PID} > \${FINISHDIR}\${FILENAME}.pid
eval \$4 1> \${FINISHDIR}\${FILENAME}.out 2> \${FINISHDIR}\${FILENAME}.err
echo \${?} > \${FINISHDIR}\${FILENAME}.ret
rm -f \${RMDIR}\${FILENAME}
EOF
)

echo "${SCRIPT}" > ${1}execcommand.sh
chmod u+x ${1}execcommand.sh
}

if [ ! -d ${SUBPROCESS_FAKE_ROOT_FOLDER} ]; then
	mkdir -p ${SUBPROCESS_FAKE_ROOT_FOLDER}
fi

SCRIPTNAME=`basename $0`
LOCKFILE=${SUBPROCESS_FAKE_ROOT_FOLDER}${SCRIPTNAME}.lock
if [ -e ${LOCKFILE} ] && kill -0 `cat ${LOCKFILE}`; then
	echo "already running"
	exit
fi

# make sure the lockfile is removed when we exit and then claim it
trap "rm -f -r ${SUBPROCESS_FAKE_ROOT_FOLDER}; exit" INT TERM EXIT
echo $$ > ${LOCKFILE}

WATCHDIR=${SUBPROCESS_FAKE_ROOT_FOLDER}${SUBFOLDER_NEW}
if [ ! -d ${WATCHDIR} ]; then
	mkdir ${WATCHDIR}
fi
FINISHDIR=${SUBPROCESS_FAKE_ROOT_FOLDER}${SUBFOLDER_FINISH}
if [ ! -d ${FINISHDIR} ]; then
	mkdir ${FINISHDIR}
fi

create_exec_command ${SUBPROCESS_FAKE_ROOT_FOLDER}

inotifywait -q -m -e close_write --format '%w %f' ${WATCHDIR} | \
while read dir file; do
	COMMAND=`cat $dir$file`
	COM="setsid ${SUBPROCESS_FAKE_ROOT_FOLDER}execcommand.sh ${file} ${SUBPROCESS_FAKE_ROOT_FOLDER}${SUBFOLDER_FINISH} ${dir} \"${COMMAND}\""
	eval ${COM} &
done

rm -f -r ${SUBPROCESS_FAKE_ROOT_FOLDER}
