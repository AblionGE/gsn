\graphicspath{{chapters/ch-architecture/figures/}}

\chapter{GSN Architecture}

\gsn is composed of three parts: data acquisition, data processing, and output
dispatching (also called notification subsystem).

\section{Data Acquisition}

Before filtering and processing data, \gsn needs to receive it. \gsn considers two types of data sources: event-based and polling-based.
In the first case, data is sent by the source and a \gsn method is called when it arrives.
Serial ports, network (TCP or UDP) connections, wireless webcams fall in this case. In the latter one, GSN periodically asks the 
source for new data. This is the case of an RSS feed or a POP3 email account.

\subsection{\gsn Wrappers \label{gsn_wrappers}}

\gsn can receive data from various data sources. This is done by using so called
wrappers. They are used to encapsulate the data received from the data source
into the standard GSN data model, called a StreamElement. A StreamElement
is an object representing a row of a SQL table.
Each wrapper is a Java class that extends the AbstractWrapper parent class.
Usually a wrapper initializes a specialized third-party library in its constructor.
It also provides a method which is called each time the library receives data from
the monitored device. This method will extract the interesting data, optionally
parse it, and create one or more StreamElement(s) with one or more columns.
From this point on, the received data has been mapped to a SQL data structure
with fields that have a name and a type. \gsn is then able to filter this using
its enhanced SQL-like syntax. You will learn more about that in section \todo{TODO: Add proper reference}
A wrapper is implemented in a Java class. For simplicity, \gsn uses short
names to refer to these wrappers. These associations are defined in the file
conf/wrappers.properties. For now on it is assumed that you use the default
names provided at installation time.

The standard \gsn wrappers are documented in Appendix \ref{sec:quickref_wrappers}.

The development of \gsn wrappers is described in Appendix \ref{sec:developer-guide_wrappers}.

\subsection{Safe Storage \label{safe_storage}}

Some acquisition systems do not internally store the data produced until GSN can process it. For instance 
the TinyOS Serial Forwarder simply sends a copy of the incoming messages to all its alive listeners. If GSN is down 
at that time, the data produced will be lost. Safe Storage is specialy developed to handle that case.
Safe Storage runs in a separate process and it aims is to simply store persistently the incoming data until the GSN process can ask for them.

These two processes communicate together upon TCP sockets and could run on different machines. The Safe Storage process acts as 
a server and GSN processes as clients. This communication and the primary storage increase the delay between the data production and the 
final storage into GSN. This results in a tradeoff between the performances and the reliability.
Moreover, GSN can run both standard wrappers and Safe Storage wrappers at the same time.

\subsubsection{Software Architecture}

Safe Storage is generic and could be added to all the already existing wrappers.
However small modifications need to be done since the Safe Storage wrappers are split into the two following parts

\begin{itemize}
	\item The acquisition part that runs in the Safe Storage process
	\item The processing part that runs in the GSN process
\end{itemize}

The wrapper class that executes on the Safe Storage should be kept as simple as possible and must extend the
\inlinecode{gsn.acquisition2.wrappers.AbstractWrapper2} abstract class.
An implementation of this class must define the methods shown on the \listingref{listing:java:safestorage_methods_to_implement}.

\begin{javacode}[caption={Methods to implement for a Safe Storage Wrapper - Safe Storage Side}, label=listing:java:safestorage_methods_to_implement]
public abstract boolean initialize ()
public abstract void finalize ()
public abstract String getWrapperName () 
public abstract void run()
\end{javacode}

The class that executes on the GSN side should do the data processing and must extend the 
\inlinecode{gsn.acquisition2.wrappers.SafeStorageAbstractWrapper} abstract class.
An implementation of this class must define the methods shown on the \listingref{listing:java:safestorage_gsn_methods_to_implement}

\begin{javacode}[caption={Methods to implement for a Safe Storage Wrapper - GSN Side}, label=listing:java:safestorage_gsn_methods_to_implement]
public DataField[] getOutputFormat()
public boolean messageToBeProcessed(DataMsg dataMessage)
\end{javacode}

\subsubsection{Safe Storage configuration}

All the wrappers that are based on Safe Storage must set the list of parameters defined in \listingref{table:safe_storage_parameters}.
The Safe Storage and Safe Storage controller port are defined in the \inlinecode{build.xml} file.

\begin{xmlcode}[caption={Safe Storage ports}, label=listing:xml:safestorage_ports]
   <property name="safe-storage-port" value="25000"/>
   <property name="safe-storage-controller-port" value="25012"/>
\end{xmlcode}

The \listingref{listing:xml:safestorage_vsd} shows an example of a \vsd that uses a Safe Storage \wrapper.

\begin{xmlcode}[caption={Sample of Email Notification VSD file}, label=listing:xml:safestorage_vsd]
<virtual-sensor name="ss_mem_vs" priority="10" >
	<processing-class>
		<class-name>gsn.vsensor.BridgeVirtualSensor</class-name>
		<output-structure>
			<field name="heap_memory_usage" type="bigint" />
			<field name="non_heap_memory_usage" type="bigint" />
			<field name="pending_finalization_count" type="int" />
		</output-structure>
	</processing-class>
	<description> Mem VS for Safe Storage Test </description>
	<life-cycle pool-size="10" />
	<addressing />
	<storage history-size="10"/>
	<streams>
		<stream name="data">
			<source alias="source" storage-size="1" sampling-rate="1">
				<address wrapper="ss_mem_processor">
					<predicate key="ss-host">localhost</predicate>
					<predicate key="ss-port">25000</predicate>
					<predicate key="continue-on-error">true</predicate>
					<predicate key="wrapper-name">mem2</predicate>
				</address>
				<query> select * from wrapper </query>
			</source>
			<query> select * from source </query>
		</stream>
	</streams>
</virtual-sensor>
\end{xmlcode}

\subsubsection{Use Cases}

When a virtual sensor that use a Safe Storage \wrapper is loaded into GSN,
a request is made to Safe Storage for the \wrapper. If the \wrapper is not already
created\footnote{In the current implementation, a Safe Storage \wrapper is identified by the following information:\newline{}
\inlinecode{<virtual-sensor-name>/<source-name>/<safe-storage-wrapper-short-name>}} 
this will create, initialize and run a new instance of the \wrapper in the Safe Storage process.
If the \wrapper was already running, it will be reused.

If the GSN process fails or is shut down, The Safe Storage \wrapper will continue to acquire the data. Once the GSN process is
restarted, all the data will be fetched from the Safe Storage DB.

If the Safe Storage process fails or is shut down, the data are not stored anymore and the GSN process will try periodically to 
connect to the Safe Storage process until the latter has been restarted.
When you restart the Safe Storage process, it will automatically create and start acquiring data for the wrappers that were loaded before.

\subsubsection{Safe Storage Management}

{
\setlength{\tymin}{10pt}
\setlength{\tymax}{0.8\textwidth}
\begin{table*}[!htp]
	\centering
	{\normalfont\footnotesize
	\begin{tabulary}{\textwidth}{|C|J|}%
	\hline
		\multicolumn{2}{|c|}{\textbf{Safe Storage ANT Tasks}} \\
	\hline
	\hline
		\textbf{Task Name} &
		\textbf{Description} \\
	\hline
	\hline
		start-acquisition &
		Start the Safe Storage process. The wrapper that were loaded during the last runs will be automatically resumed and will directly start acquiring data. \\
	\hline
		clean-acquisition &
		Delete all the Safe Storage permanent storage and flush the list of Wrappers to resume. Use this task with caution since it may delete unprocessed data. \\
	\hline
		stop-acquisition &
		Stop the Safe Storage process. \\
	\hline
	\hline
		\multicolumn{2}{|l|}{Use each of these tasks by typing in your terminal: \inlinecode{ant <Task Name>}} \\
	\hline
	\end{tabulary}
	}
	\caption{Safe Storage ANT Tasks}
	\label{table:safestorage_ant_tasks}
\end{table*}
}

\section{Data Filtering and Processing}

GSN provides two complementary mechanisms to work on data.
The first one is based on a SQL syntax enhanced with specialized semantics
for timed sliding windows and event counting.
The second one allows to manipulate data with specialized programs called
virtual sensors. GSN comes with a library of virtual sensors that you can use
without programming. If you have more sophisticated needs, you can write your
own virtual sensors (See \todo{add reference to Appendix ?}).

GSN always processes the data according to a virtual sensor configuration.
If you only want to use the SQL filtering mechanism, without any data trans-
formation, you can use the BridgeVirtualSensor (see \todo{add reference to Appendix ?}).
If you don't want to use the SQL filtering mechanism, simply select all data
from the wrapper.

\subsection{Virtual Sensors}

Virtual Sensor is the main abstraction used by GSN to represent a well structured data stream.
By well structured we mean, the structure of the stream is known in advanced and it is not going to be changed
while GSN is running.
\subsubsection{Introduction}
Virtual sensors are small Java programs that register to GSN with a specific
SQL query for their data input. This query is configured by the user. When
GSN receives data that matches the filter at the entry of a virtual sensor, this
data is sent to the virtual sensor, which usually performs some sort of operation
depending of the received data, and finally publishes some data (it may also
produce nothing).
Virtual sensors are configured in the virtual-sensors directory. You can edit
the configuration of a virtual sensor online while GSN is running, because GSN
periodically scans this directory for updates. This can be very useful when you
are learning how to use GSN: you can immediately see the effect of modifying
a query.

\subsubsection{The virtual-sensor xml configuration file}

A virtual sensor configuration file starts with the virtual-sensor tag. It takes
three parameters, name, priority and password. The first one is mandatory
and arbitrary (the only constraint is that the name should be unique in this
GSN configuration), and the two others are optional. 0 is the highest priority
and 20 is the lowest. The default priority is 10.
The first tag inside a virtual-sensor is usually processing-class. The first tag
inside this group is class-name, and gives the class name of the \vsp
to be used in this coniguration. After this comes an optional init-params
section.
We will work with an example to better understand these concepts. We
present here a configuration for the ChartVirtualSensor that gets data from
another virtual sensor, named MemoryMonitorVS. These two configurations can
be found in the default installation of GSN under the names memoryDataVS.xml
and memoryPlotVS.xml.

\begin{xmlcode}[caption={\vsd Example}, label=listing:xml:vsd-example]
<virtual-sensor name="MemoryPlotVS" >
	<processing-class>
	<class-name>gsn.vsensor.ChartVirtualSensor</class-name>
		<init-params>
			<param name="input-Stream">DATA</param>
			<param name="title">GSN Memory Usage</param>
			<param name="type">ANY</param>
			<param name="height">200</param>
			<param name="width">300</param>
			<param name="vertical-axis">Sensor Readings</param>
			<param name="history-size">100</param>
		</init-params>
		<output-structure>
			<field name="DATA" type="binary:image/jpeg"/>
		</output-structure>
	</processing-class>
	<description>My chart virtual sensor<description>
	<life-cycle pool-size="10"/>
	<addressing>
		<predicate key="geographical">BC building EPFL</predicat>
	</addressing>
	<storage history-size="1" />
	<streams>
		<stream name="DATA" rate="100">
			<source alias="source1" storage-size="1 sampling-rate="1">
				<address wrapper="remote">
					<predicate key="HOST"> localhost </predicate>
					<predicate key="PORT"> 22001  </predicate>
					<predicate key="NAME">  MemoryMonitorVS  </predicate>
				</address>
				<query>
					select HEAP,NON_HEAP,
					PENDING_FINALIZATION_COUNT,TIMED
					from wrapper
				</query>
			</source>
			<query>	select * from source1 </query>
		</stream>
	</streams>
</virtual-sensor>
\end{xmlcode}

\subsubsection{What if the structure of the virtual sensor changes?}
We are not changing the structure of the database automatically (adding or droping fields). If your virtual sensors structure
changes and if you are using \emph{permannet storages} such as MySQL or File-based HSQLDB, you have to change the structure of the
table manually.\subsection{Graphical Representation}

\subsubsection{SQL Syntax}

\section{Data publishing}

\subsection{Web Interface}

GSN ships with an elegant and easy to use web interface. The only thing
you have to do is to open a web browser and go the following address: http:
//127.0.0.1:22001 .

\subsubsection{GoogleMaps integration}
GSN can associate your data with GPS positions and then display these on
a world map retrieved from Google's GoogleMaps service. You need a special
identification key from Google. For more information, please refer to the docu-
mentation file doc/README.txt, section 'How to use GoogleMaps with GSN'.

\subsection{GSN Notifications}

\subsubsection{Introduction}

In GSN, virtual sensors can be configured to notify users of certain events, e.g. to send an Email notification to an user informing them that a particular event has occurred. To implement notifications in GSN is very straight forward. The basic principle is that once the virtual sensor query is answered as specified in the virtual sensor description file, e.g.

\begin{xmlcode}
<query>SELECT temperature FROM s1 WHERE temperature >= 100</query>
\end{xmlcode}

a notification can be triggered  by the java processing class

\begin{xmlcode}
<class-name>gsn.vsensor.EmailVirtualSensor</class-name>
\end{xmlcode}

see examples in next section. Thus, any type of notifications, e.g. Email, SMS, SIP, Fax, MMS can be implemented easily in a virtual sensor processing class. 

The technical details of implementing notifications are left to the designer. Below are three examples of some of the notification services already implemented in GSN.


\section{Notes}


\subsubsection{Where is the DTD for the virtual sensor?}
We are using JiBX Java-XML binding project. The structure of the virtual sensor descriptor file is defined in \texttt{conf/VirtualSensorDescription.xml}.

Have a look to the \chapref{quickref_vsd_dtd}.

\subsubsection{Which databases we support ?}
At the moment we are supporting HSqlDB and MySQL. Checkout the mailing list for the latest issues regarding the other databases and their
support status.
\subsubsection{Which projects are using GSN ?}
There are over 10 EU/Swiss funding research projects using GSN as their core technology.
\subsubsection{GSN.XML file}
\subsection{GeoRSS}
\subsection{Network communication}
Looking inside the GSN infrastructure, there are at least half a dozen difference network communication channels are used. In this section I would like to dive in to the details
of the some major communication protocols designed and implemented in GSN. 

\subsubsection{Reusing Data Streams}

One of the main ideas behind the virtual sensors is resuability. The resuability comes in two forms.
First being able to recreate the same processing logic on different data streams.
Second being able to reuse streaming data produced by other parties over the internet and possibly create a new data stream but instrumenting the original streams.
In this section, I present the both high level and low level details associated with the second aspect of the reusability.

The virtual sensor descriptor file is the first place which specifies the intention of reusing streaming data from another virtual sensor. The source virtual sensor can be located
anywhere as long as it is accessible through the network, this ofcourse includes the local machine and any other machine on the Internet. 


In GSN, our vision is having an internet scale streaming world in which people can publish streaming data which
can be produced directly using some sort of a measurement device which can range from a physical wireless sensor to stock ticks from a financial market.







