\graphicspath{{chapters/ch-architecture/figures/}}

\chapter{GSN Architecture}

\section{Data Acquisition}

 Before filtering and processing data, GSN needs to receive it. GSN considers two types of data sources: event-based and polling-based.
 In the first case, data is sent by the source and a GSN method is called when it arrives.
 Serial ports, network (TCP or UDP) connections, wireless webcams fall in this case. In the latter one, GSN periodically asks the 
 source for new data. This is the case of an RSS feed or a POP3 email account.

\section{Safe Storage \label{safe_storage}}

Some acquisition systems do not internally store the data produced until GSN can process it. For instance 
the TinyOS Serial Forwarder simply sends a copy of the incoming messages to all its alive listeners. If GSN is down 
at that time, the data produced will be lost. Safe Storage is specialy developed to handle that case.
Safe Storage runs in a separate process and it aims is to simply store persistently the incoming data until the GSN process can ask for them.

These two processes communicate together upon TCP sockets and could run on different machines. The Safe Storage process acts as 
a server and GSN processes as clients. This communication and the primary storage increase the delay between the data production and the 
final storage into GSN. This results in a tradeoff between the performances and the reliability.
Moreover, GSN can run both standard wrappers and Safe Storage wrappers at the same time.

\subsection{Software Architecture}

Safe Storage is generic and could be added to all the already existing wrappers.
However small modifications need to be done since the Safe Storage wrappers are splitted in the two following parts

\begin{itemize}
	\item The acquisition part that runs in the Safe Storage process
	\item The processing part that runs in the GSN process
\end{itemize}

The wrapper class that executes on the Safe Storage should be kept as simple as possible and must extends the
\inlinecode{gsn.acquisition2.wrappers.AbstractWrapper2} abstract class.
An implementation of this class must define the methods shown on the \listingref{listing:java:safestorage_methods_to_implement}.

\begin{javacode}[caption={Methods to implement for a Safe Storage Wrapper - Safe Storage Side}, label=listing:java:safestorage_methods_to_implement]
public abstract boolean initialize ()
public abstract void finalize ()
public abstract String getWrapperName () 
public abstract void run()
\end{javacode}

The class that executes on the GSN side should do the data processing and must extends the 
\inlinecode{gsn.acquisition2.wrappers.SafeStorageAbstractWrapper} abstract class.
An implementation of this class must define the methods shown on the \listingref{listing:java:safestorage_gsn_methods_to_implement}

\begin{javacode}[caption={Methods to implement for a Safe Storage Wrapper - GSN Side}, label=listing:java:safestorage_gsn_methods_to_implement]
public DataField[] getOutputFormat()
public boolean messageToBeProcessed(DataMsg dataMessage)
\end{javacode}

\subsection{Safe Storage configuration}

All the wrappers that are based on Safe Storage must set the list of parameters defined in \listingref{table:safe_storage_parameters}.
The Safe Storage and Safe Storage controller port are defined in the \inlinecode{build.xml} file.

\begin{xmlcode}[caption={Safe Storage ports}, label=listing:xml:safestorage_ports]
   <property name="safe-storage-port" value="25000"/>
   <property name="safe-storage-controller-port" value="25012"/>
\end{xmlcode}

The \listingref{listing:xml:safestorage_vsd} shows an example of \vsd that use a Safe Storage \wrapper.

\begin{xmlcode}[caption={Sample of Email Notification VSD file}, label=listing:xml:safestorage_vsd]
<virtual-sensor name="ss_mem_vs" priority="10" >
	<processing-class>
		<class-name>gsn.vsensor.BridgeVirtualSensor</class-name>
		<output-structure>
			<field name="heap_memory_usage" type="bigint" />
			<field name="non_heap_memory_usage" type="bigint" />
			<field name="pending_finalization_count" type="int" />
		</output-structure>
	</processing-class>
	<description> Mem VS for Safe Storage Test </description>
	<life-cycle pool-size="10" />
	<addressing />
	<storage history-size="10"/>
	<streams>
		<stream name="data">
			<source alias="source" storage-size="1" sampling-rate="1">
				<address wrapper="ss_mem_processor">
					<predicate key="ss-host">localhost</predicate>
					<predicate key="ss-port">25000</predicate>
					<predicate key="continue-on-error">true</predicate>
					<predicate key="wrapper-name">mem2</predicate>
				</address>
				<query> select * from wrapper </query>
			</source>
			<query> select * from source </query>
		</stream>
	</streams>
</virtual-sensor>
\end{xmlcode}

\subsection{Use Cases}

When a virtual sensor that use a Safe Storage \wrapper is loaded into GSN,
a request is made to Safe Storage for the \wrapper. If the \wrapper is not already
created\footnote{In the current implementation, a Safe Storage \wrapper is identified by the following information:\newline{}
\inlinecode{<virtual-sensor-name>/<source-name>/<safe-storage-wrapper-short-name>}} 
this will create, initialize and run a new instance of the \wrapper in the Safe Storage process.
If the \wrapper was already running, it will be reused.

If the GSN process fails or is shutted down, The Safe Storage \wrapper will continue to acquire the data. Once the GSN process is
restarted, all the data will be fetched from the Safe Storage DB.

If the Safe Storage process fails or is shutted down, the data are not stored anymore and the GSN process will try periodically to 
connect to the Safe Storage process until the latter has been restarted.
When you restart the Safe Storage process, it will automatically create and start acquiring data for the wrappers that were loaded before.

\subsection{Safe Storage Management}

{
\setlength{\tymin}{10pt}
\setlength{\tymax}{0.8\textwidth}
\begin{table*}[!htp]
	\centering
	{\normalfont\footnotesize
	\begin{tabulary}{\textwidth}{|C|J|}%
	\hline
		\multicolumn{2}{|c|}{\textbf{Safe Storage ANT Tasks}} \\
	\hline
	\hline
		\textbf{Task Name} &
		\textbf{Description} \\
	\hline
	\hline
		start-acquisition &
		Start the Safe Storage process. The wrapper that were loaded during the last runs will be automatically resumed and will directly start acquiring data. \\
	\hline
		clean-acquisition &
		Delete all the Safe Storage permanent storage and flush the list of Wrappers to resume. Use this task with caution since it may delete unprocessed data. \\
	\hline
		stop-acquisition &
		Stop the Safe Storage process. \\
	\hline
	\hline
		\multicolumn{2}{|l|}{Use each of these tasks by typing in your terminal: \inlinecode{ant <Task Name>}} \\
	\hline
	\end{tabulary}
	}
	\caption{Safe Storage ANT Tasks}
	\label{table:safestorage_ant_tasks}
\end{table*}
}

\section{Virtual Sensors}
\section{Introduction}
Virtual Sensor is the main abstraction used by GSN to represent a well structured data stream.
By well structured we mean, the structure of the stream is known in advanced and it is not going to be changed
while GSN is running.
\section{Graphical Representation}

\section{Notes}

\subsection{What if the structure of the virtual sensor changes?}
We are not changing the structure of the database automatically (adding or droping fields). If your virtual sensors structure
changes and if you are using \emph{permannet storages} such as MySQL or File-based HSQLDB, you have to change the structure of the
table manually.

\subsection{Where is the DTD for the virtual sensor?}
We are using JiBX Java-XML binding project. The structure of the virtual sensor descriptor file is defined in \texttt{conf/VirtualSensorDescription.xml}.

Have a look to the \chapref{quickref_vsd_dtd}.

\subsection{Which databases we support ?}
At the moment we are supporting HSqlDB and MySQL. Checkout the mailing list for the latest issues regarding the other databases and their
support status.
\subsection{Which projects are using GSN ?}
There are over 10 EU/Swiss funding research projects using GSN as their core technology.
\section{GSN.XML file}
\section{SafeStorage}
\subsection{Why we need it? }
\subsection{How to use it }
\subsection{How to write a wrapper for the safe storage}
\section{Wrappers}
\section{Their mandatory parameters}
\section{How it works}
\section{Introduction}
\section{GeoRSS}
\section{SQL Syntax}
\section{Introduction}
\section{Introduction}
\section{Introduction}
\section{Introduction}
\section{Introduction}
\section{Introduction}
\section{Introduction}
\section{Network communication}
Looking inside the GSN infrastructure, there are at least half a dozen difference network communication channels are used. In this section I would like to dive in to the details
of the some major communication protocols designed and implemented in GSN. 

\subsection{Reusing Data Streams}

One of the main ideas behind the virtual sensors is resuability. The resuability comes in two forms.
First being able to recreate the same processing logic on different data streams.
Second being able to reuse streaming data produced by other parties over the internet and possibly create a new data stream but instrumenting the original streams.
In this section, I present the both high level and low level details associated with the second aspect of the reusability.

The virtual sensor descriptor file is the first place which specifies the intention of reusing streaming data from another virtual sensor. The source virtual sensor can be located
anywhere as long as it is accessible through the network, this ofcourse includes the local machine and any other machine on the Internet. 


In GSN, our vision is having an internet scale streaming world in which people can publish streaming data which
can be produced directly using some sort of a measurement device which can range from a physical wireless sensor to stock ticks from a financial market.

\section{GSN Notifications}

\subsection{Introduction}

In GSN, virtual sensors can be configured to notify users of certain events, e.g. to send an Email notification to an user informing them that a particular event has occurred. To implement notifications in GSN is very straight forward. The basic principle is that once the virtual sensor query is answered as specified in the virtual sensor description file, e.g.

\begin{xmlcode}
<query>SELECT temperature FROM s1 WHERE temperature >= 100</query>
\end{xmlcode}

a notification can be triggered  by the java processing class

\begin{xmlcode}
<class-name>gsn.vsensor.EmailVirtualSensor</class-name>
\end{xmlcode}

see examples in next section. Thus, any type of notifications, e.g. Email, SMS, SIP, Fax, MMS can be implemented easily in a virtual sensor processing class. 

The technical details of implementing notifications are left to the designer. Below are three examples of some of the notification services already implemented in GSN.






